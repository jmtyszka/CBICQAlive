#!/bin/bash
#
# Run in vivo QA on one or more 4D EPI fMRI datasets
# - Runs single-series QA reporting for all volumes in provided list.
# - Creates a results directory at the same level as each EPI file.
# - Creates summary CSV file for all volumes in the working directory.
#
#
# USAGE : cbicqalive <List of 4D Nifti fMRI volumes>
# EXAMPLE : cbicqalive */*/*_rsbold.nii.gz
#
# AUTHOR : Mike Tyszka, Ph.D.
# PLACE  : Caltech
# DATES  : 2014-02-12 JMT From scratch
#          2016-02-12 JMT Add HTML and PDF report generation
#          2016-07-13 JMT Add multifile batching and complete HTML reporting
#
# Copyright 2014-2016 California Institute of Technology
# All rights reserved.

if [ $# -lt 1 ]; then
  echo "USAGE   : cbicqalive <List of 4D Nifti fMRI volumes>"
	echo "EXAMPLE : cbicqalive */*/*_rsbold.nii.gz"
  exit
fi

# Loop over file list
for epi_file in $*
do

	# Check that EPI file exists
	if [ ! -s ${epi_file} ]; then
		echo "${epi_file} does not exist - skipping"
		exit
	fi

	# TR required for high pass filtering
	TR_secs=`fslinfo ${epi_file} | awk '{ if ( $1 == "pixdim4") print $2}'`

	# Number of volumes in timeseries
	N_vols=`fslinfo ${epi_file} | awk '{ if ($1 == "dim4") print $2 }'`

	# Splash
	echo ""
	echo "------------------------------------------"
	echo "QALive : in vivo quality assurance metrics"
	echo "------------------------------------------"
	echo "4D EPI Data : ${epi_file}"
	echo "TR (s)      : ${TR_secs}"
	echo "Num Vols    : ${N_vols}"
	echo ""

	# Find containing directory
	root_dir=`dirname $epi_file`

	# Strip extension from EPI file
	epi_stub=${epi_file%%.nii.gz}

	# Create a QALive directory at the same level
	# Leave deletion of files to user since this script reuses previous results where possible
	qa_dir=${epi_stub}.qalive
	if [ ! -d ${qa_dir} ]; then
		echo "Creating QALive directory"
		mkdir -p ${qa_dir}
	fi

	# Key filenames
	qa_info=${qa_dir}/qa_info.txt
	qa_mcf=${qa_dir}/qa_mcf
	qa_filt=${qa_dir}/qa_filt
	qa_tmean=${qa_dir}/qa_tmean
	qa_tsd=${qa_dir}/qa_tsd
	qa_tsnfr=${qa_dir}/qa_tsnfr
	qa_mask=${qa_dir}/qa_mask
	qa_brain_mask=${qa_dir}/qa_brain_mask
	qa_tsnr_mean=${qa_dir}/qa_tsnr_mean.txt
	qa_mcf_par=${qa_dir}/qa_mcf.par
	qa_mcf_mean=${qa_dir}/qa_mcf_mean.txt
	qa_dvars_ts=${qa_dir}/qa_dvars_ts.txt
	qa_roi_ts=${qa_dir}/qa_roi_ts.txt

	# Check whether MOCO has already been performed
	if [ -s ${qa_mcf}.nii.gz ] && [ -s ${qa_mcf_par} ]; then
		echo "Motion correction has already been done - skipping"
	else
		echo "Motion correcting"
		# Run mcflirt on QA Nifti file
		# Output file defaults to qa_mcf.nii.gz, parameters in qa_mcf.par
		mcflirt -in ${epi_file} -out ${qa_mcf} -refvol 0 -plots

	fi

	#
	# Non-linear high pass filtering to remove slow baselines
	# Standard step in FEAT pipeline

    if [ -s ${qa_filt}.nii.gz ]; then
        echo "Temporal high pass filtering has already been done - skipping"
    else
        sigma_seconds=50.0
        sigma_vols=`echo $TR_seconds | awk -v s=${sigma_seconds} '{ print s / $1 }'`
        echo "Temporal high pass filtering : sigma = ${sigma_seconds} seconds, ${sigma_vols} volumes"
        fslmaths ${qa_mcf} -bptf ${sigma_vols} -1 ${qa_filt}
    fi

	#
	# Temporal summary images
	#

	if [ -s ${qa_tmean}.nii.gz ]
	then
		echo "  Mean image exists - skipping"
	else
		echo "  Calculating tMean image from motion corrected data"
		fslmaths ${qa_mcf} -Tmean ${qa_tmean}
	fi

	# Temporal SD of registered images
	if [ -s ${qa_tsd}.nii.gz ]
	then
		echo "  SD image exists - skipping"
	else
		echo "  Calculating temporal fluctuation noise SD"
		fslmaths ${qa_mcf} -Tstd ${qa_tsd}
	fi

	# Voxel-wise tSNFR image
	if [ -s ${qa_tsnfr}.nii.gz ]
	then
		echo "  tSNFR image exists - skipping"
	else
		echo "  Estimating tSNFR image (tMean / tSD)"
		fslmaths ${qa_tmean} -div ${qa_tsd} ${qa_tsnfr}
	fi

	#
	# Regional mask creation from temporal mean image
	#

	if [ -s ${qa_mask}.nii.gz ]
	then
		echo "  Mask image exists - skipping"
	else

		# Temporary Nifti files
		tmp_signal=${qa_dir}/tmp_signal
		tmp_signal_dil=${qa_dir}/tmp_signal_dil
		tmp_brain=${qa_dir}/tmp_brain
		tmp_brain_mask=${tmp_brain}_mask
		tmp_nyquist=${qa_dir}/tmp_nyquist
		tmp_upper=${qa_dir}/tmp_upper
		tmp_lower=${qa_dir}/tmp_lower
		tmp_air=${qa_dir}/tmp_air

		# Signal threshold for basic segmentation
		# 10% of the 99th percentile of intensity
		signal_threshold=`fslstats $qa_tmean -p 99 | awk '{ print $1 * 0.1 }'`
		
		# Signal mask
		echo "  Creating signal mask (threshold = ${signal_threshold})"
		fslmaths ${qa_tmean} -thr ${signal_threshold} -bin ${tmp_signal}

		# Brain mask (use FSL BET)
		echo "  Creating brain mask"
		bet ${qa_tmean} ${tmp_brain} -m -R

		# Erode signal mask once, then dilate twice
		echo "  Open and dilate signal mask (5 mm radius kernel)"
		fslmaths ${tmp_signal} -kernel sphere 5.0 -ero -dilF -dilF ${tmp_signal_dil}

		echo "  Creating Nyquist mask"
		# Determine y dimension (PE dim in EPI)
		half_ny=`fslinfo ${qa_tmean} | awk '{ if ($1 == "dim2") print $2/2 }'`

		# Extract upper and lower halves of dilated volume mask in Y dimension (PE)
		fslroi ${tmp_signal_dil} ${tmp_lower} 0 -1 0 ${half_ny} 0 -1 0 -1
		fslroi ${tmp_signal_dil} ${tmp_upper} 0 -1 ${half_ny} -1 0 -1 0 -1
		
		# Create shifted (Nyqusit) mask from swapped upper and lower masks
		fslmerge -y ${tmp_nyquist} ${tmp_upper} ${tmp_lower}
		
		# Correct y offset in sform matrix
		sform=`fslorient -getsform ${tmp_signal}`
		fslorient -setsform ${sform} ${tmp_nyquist}
		
		# XOR Nyquist and dilated signal masks
		fslmaths ${tmp_nyquist} -mul ${tmp_signal_dil} -mul -1.0 -add ${tmp_nyquist} ${tmp_nyquist}
		
		echo "  Creating air mask"
		# Create air mask by subtracting Nyquist mask from NOT dilated signal mask
		fslmaths ${tmp_signal_dil} -binv -sub ${tmp_nyquist} ${tmp_air}
		
		# Finally merge all three masks into an indexed file
		# Phantom = 1
		# Nyquist = 2
		# Air     = 3
		fslmaths ${tmp_nyquist} -mul 2 ${tmp_nyquist}
		fslmaths ${tmp_air} -mul 3 ${tmp_air}
		fslmaths ${tmp_brain_mask} -add ${tmp_nyquist} -add ${tmp_air} ${qa_mask}

		# Save brain mask
		imcp ${tmp_brain_mask} ${qa_brain_mask}

		# Clean up temporary images
		echo "  Cleaning up temporary images"
		rm -rf ${qa_dir}/tmp*.*

	fi

	# Create orthogonal slice views temporal summary images and masks
	scale_factor=2.5
	slicer ${qa_tmean} -s ${scale_factor} -a ${qa_dir}/qa_tmean_ortho.png
	slicer ${qa_tsd} -s ${scale_factor} -a ${qa_dir}/qa_tsd_ortho.png
	slicer ${qa_tsnfr} -s ${scale_factor} -a ${qa_dir}/qa_tsnfr_ortho.png
	slicer ${qa_mask} -s ${scale_factor} -a ${qa_dir}/qa_mask_ortho.png

	# DVARS timecourse
	if [ -s ${qa_dvars_ts} ]; then
		echo "  DVARS timecourse exists - skipping"
	else
		echo "  Calculating DVARS timecourse within brain mask for motion corrected data"
		fsl_motion_outliers -i ${qa_mcf} -m ${qa_brain_mask} -o /dev/null -s ${qa_dvars_ts} --dvars --nomoco
	fi

	# Extract time-series stats within each ROI
	if [ -s ${qa_roi_ts} ]; then
		echo "  Signal timecourses exist - skipping"
	else
		echo "  Extracting mean signal timecourses for each region"
		# Timecourse of mean signal within each mask label
		fslmeants -i ${qa_mcf} -o ${qa_roi_ts} --label=${qa_mask}
	fi

    # Write dataset info to QA directory
    echo "  Saving dataset information"
    echo "TR_secs, ${TR_secs}" > ${qa_info}
    echo "N_vols, ${N_vols}" >> ${qa_info}

	# Generate summary statistics and plots in QA directory
	cbicqalive_stats.py -i ${qa_dir}

	# Generate HTML report page (index.html) in QA directory
	cbicqalive_report.py -i ${qa_dir}

done # File list loop

# Done
echo "Finished at : `date`"
